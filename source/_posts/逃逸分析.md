---
title: go 逃逸分析
date: 2021-09-14 20:15:00
tags:
    - golang   
category:
    - 后端
thumbnail: /thumbnails/max1.png
---

#### GO中的栈和堆

>  在Go中，**栈的内存是由编译器自动进行分配和释放，栈区往往存储着函数参数、局部变量和调用函数帧，它们随着函数的创建而分配，函数的退出而销毁**。一个goroutine对应一个栈，栈是调用栈（call stack）的简称。
>
> 与栈不同的是，应用程序在运行时只会存在一个堆。狭隘地说，内存管理只是针对堆内存而言的。程序在运行期间可以主动从堆上申请内存，这些内存通过Go的内存分配器分配，并由垃圾收集器回收。
>
> 栈是每个goroutine独有的，这就意味着栈上的内存操作是不需要加锁的。而**堆上的内存，有时需要加锁防止多线程冲突**。在栈上的内存而言，它的分配与释放非常廉价。简单地说，它只需要两个CPU指令：一个是分配入栈，另外一个是栈内释放。而这，只需要借助于栈相关寄存器即可完成。
>
> **栈内存能更好地利用CPU的缓存策略。因为它们相较于堆而言是更连续的**



#### 我们如何知道一个对象是放在堆上了还是栈上了？

答案：逃逸分析！编译器通过逃逸分析技术去选择堆或者栈，逃逸分析的基本思想如下：**检查变量的生命周期是否是完全可知的，如果通过检查，则可以在栈上分配。否则，就是所谓的逃逸，必须在堆上进行分配。**

上面这句话如何理解`完全可知`?

- 如果变量在函数外部没有引用，则优先放到栈中；
- 如果变量在函数外部存在引用，则必定放在堆中；


 <!-- more -->
#### GO的逃逸分析概览

> go的传值会在栈上分配，但一旦将某个局部变量以指针方式传出，该变量就会逃逸到堆上了。
>
> 未逃逸的变量则直接在栈上分配内存。因为栈上内存由函数返回时自动回收，减少gc压力（jvm）
>
> golang的逃逸分析不同于jvm，他是**编译期**就完成了逃逸，并且go的逃逸**只针对指针**。



#### 查看逃逸分析的方法

- go run -gcflags "-m -l" (-m打印逃逸分析信息，-l禁止内联编译) main.go
- go tool compile -S main.go | grep runtime.newobject （汇编代码中搜runtime.newobject指令，该指令用于生成堆对象）



#### 什么情况会发生逃逸？

1. 函数内部创建出的变量，将其指针作为函数返回值，则该变量一定发生逃逸。

```go
func test() *User{
    a := User{}
    return &a
}
```

2. 被已经逃逸的变量引用的指针，一定发生逃逸(此例子可展开，查看煎鱼大佬的博客)

```go
type User struct {
	Username string
	Password string
	Age      int
}

func main() {
	a := "aaa"
	u := &User{a, "123", 12}
	Call1(u)
}

func Call1(u *User) {
	fmt.Printf("%v",u) //逃逸
}
//因为fmt.Println的函数参数为interface类型，编译期不能确定其参数的具体类型，所以将其分配于堆上(逃逸分析的基本思想 `完全可知`)
//所以我们在编码时应尽量减少interface这类不透明的类型
//查看fmt的源码，发现u被赋予给了一个p指针。而这个p是由newPrinter返回的，所以p一定逃逸（原因是第一种），从而导致 u也一定逃逸

```

3. 被引用类型（slice、map和chan）引用的指针一定发生逃逸

```go
func main() {
	a := make([]*int,1)
	b := 12
	a[0] = &b //b逃逸

	c := make(map[string]*int)
	d := 14
	c["aaa"]=&d //d 逃逸

	e := make(chan *int,1)
	f := 15
	e <- &f	//f 逃逸
}
```

4. 变量占用内存空间大
5. 变量大小不确定 （make([]int, n)  ）——为了保证内存的绝对安全，Go的编译器可能会将一些变量不合时宜地分配到堆上，但是因为这些对象最终也会被垃圾收集器处理，所以也能接受



#### 什么情况不会发生逃逸？

- 指针被未发生逃逸的变量引用
- 仅仅在函数内对变量做取址操作，而未将指针传出



#### 搞清逃逸分期的好处

尽量写出分配在栈上的代码，堆上的变量变少了，可以减轻内存分配的开销，减小gc的压力，提高程序的运行速度。

从GC的角度来看，指针传递是个双刃剑，需要谨慎使用，否则线上调优解决GC延时可能会让你崩溃。



#### References

1. https://zhuanlan.zhihu.com/p/91559562

2. https://zhuanlan.zhihu.com/p/343562181